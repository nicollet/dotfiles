" generated by puppet from: modules/accounts/files/xnicollet/.vimrc

set encoding=utf-8
set nocompatible

syntax on
syntax sync minlines=512 " start highlighting from 512 lines backward
set synmaxcol=300 " do noe highlight very long lines
set bg=dark

filetype plugin indent on

au BufRead,BufNewFile Vagrantfile setfiletype ruby
set modelines=5
set modeline

" pas de highlight abusif
set nohls

" set list | set nolist
" set listchars=tab:\|-,trail:.
set listchars=tab:Â»\ ,trail:.,nbsp:~

"  " should be called before go plugin is launched
"  function! GoHtml()
"  	GoFmt
"  	if !empty(b:current_syntax)
"  		unlet b:current_syntax
"   	endif
"   	syn include @html syntax/html.vim
"  	syntax region htmlCode start=+<!DOCTYPE+ keepend end=+</html>+ contains=@html containedin=goRawString contained
"  endfunction
"
"  " autocmd BufEnter *.go call GoHtml()
"  autocmd BufWrite *.go call GoHtml()

" http://stackoverflow.com/questions/18576651/check-whether-pathogen-is-installed-in-vimrc
runtime! autoload/pathogen.vim
if exists("*pathogen#infect")
	call pathogen#infect()
endif

filetype plugin indent on

inoremap jk <Esc>l

" remove arrows
for prefix in ['i', 'n', 'v']
	for key in ['<Up>', '<Down>', '<Left>', '<Right>']
		exe prefix . "noremap " . key . " <Nop>"
	endfor
endfor

let mapleader = "\<Space>"

function! NiceCurlyBrace()
	if &runtimepath =~ 'vim-go'
		execute "normal! a{"
		if getline('.') =~ 'func\|if\|for\|type\|else'
			execute "normal a\<CR>}"
			execute "normal O\<Space>\<BS>\<ESC>"
		endif
	endif
endfunction

if &runtimepath =~ 'vim-go'
	function! FormatAndImports()
		GoFmt
		GoImports
	endfunction

	function! SetGoOptions()
		nmap <Leader>gr <Plug>(go-run)
		nmap <Leader>gb <Plug>(go-build)
		nmap <Leader>gt <Plug>(go-test)
		nmap <Leader>gT <Plug>(go-test-func)
		nmap <Leader>gd <Plug>(go-doc-browser)
		nmap <Leader>gD <Plug>(go-def)
		nmap <Leader>gR <Plug>(go-rename)
		nmap <Leader>gf <Plug>(go-freevars)
		nmap <Leader>gl <Plug>(go-metalinter)
		nmap <Leader>ga <Plug>(go-alternate-edit)
		inoremap { <Esc>:call NiceCurlyBrace()<CR>a
		inoremap "" ""<Esc>i
		inoremap '' '_'<Esc>hr
		set list
		let g:go_fmt_autosave = 0
		let g:go_fmt_options = "-s -w"

		" for golang: automatically run GoImports
		" let g:go_fmt_command = "GoImports"
		" simplify code when formatting
		autocmd BufWritePre *.go call FormatAndImports()
	endfunction


	"	augroup golang
	"		autocmd!
	au FileType go call SetGoOptions()
	au FileType go setl list ts=2 sw=2 noet
	"	augroup end
endif

augroup puppet
	au FileType puppet setl list ts=2 sw=2 et
augroup end

augroup vim
	au FileType vim setl list ts=2 sw=2 noet
augroup end

" Google style guide for bash
augroup bash
	autocmd!
	au FileType sh setl list sw=2 ts=2 et
augroup end

" let's test hidden mode
set hidden

nnoremap ' `
nnoremap ` '

set history=100
set visualbell

cnoremap w!! w !sudo tee %
" make C-g behave like C-c in command mode
cnoremap <C-g> <C-c>

" todo remap set number to set number relativenumber
" when printing number, use relative numbers so that we can 3dd easily
" set relativenumber

" open vimrc more easily
nnoremap <Leader>ev :e $MYVIMRC<cr>
" todo: improve this: should only save $MYVIMRC
nnoremap <Leader>sv :w<cr> :source $MYVIMRC<cr>
" should find a way to close it easily

" sane backspace
set backspace=2

" don't put too large text by mistake
highlight ColorColumn ctermbg=darkblue
call matchadd('ColorColumn', '\%81v', 100)

set laststatus=2
" we need more colors
" set t_Co=256

" know where the cursor is located
set noruler

" http://got-ravings.blogspot.com/2008/08/vim-pr0n-making-statuslines-that-own.html
set statusline=   " clear the statusline for when vimrc is reloaded

" syntastic
if exists('SyntasticStatuslineFlag')
	set statusline+=%#warningmsg#
	set statusline+=%{SyntasticStatuslineFlag()}
	set statusline+=%*
endif

set statusline+=%-3.3n\                      " buffer number
set statusline+=%f\                          " file name
set statusline+=%h%m%r%w                     " flags
set statusline+=[%{strlen(&ft)?&ft:'none'},  " filetype
set statusline+=%{strlen(&fenc)?&fenc:&enc}, " encoding
set statusline+=%{&fileformat}]              " file format
set statusline+=%=                           " right align
" set statusline+=%{synIDattr(synID(line('.'),col('.'),1),'name')}\  " highlight
" set statusline+=%b,0x%-8B\                   " current char
" set statusline+=%-14.(%l,%c%V%)\ %<%P        " offset
set statusline+=%10((%l,%c)%)\            " line and column
set statusline+=%p%%                        " percentage of file

" help for file
set wildmenu
" set wildmode=longest,list:full
" testing a new version
set wildmode=list:longest,full
" Ignore compiled files
set wildignore+=.o,~,pyc
set wildignore+=.git,.hg,.svn

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" just a try: let's forget ;
nnoremap ; :
" maybe later:  nnoremap : ;

set autowrite

" Looks like unimpaired.vim
function! s:setup_paste() abort
	set paste
	augroup unimpaired_paste
		autocmd!
		autocmd InsertLeave *
			\ set nopaste |
			\ autocmd! unimpaired_paste
	augroup end
endfunction

nnoremap <silent> yo :call <SID>setup_paste()<CR>o
nnoremap <silent> yO :call <SID>setup_paste()<CR>O

set completeopt=menu,menuone
if &runtimepath =~ 'neocomplete'
	let g:acp_enableAtStartup = 0
	let g:neocomplete#enable_at_startup = 1
	let g:neocomplete#enable_smart_case = 1

	if !exists('g:neocomplete#sources')
		let g:neocomplete#sources = {}
	endif
	let g:neocomplete#sources._ = ['buffer', 'member', 'tag', 'file', 'dictionary']
	let g:neocomplete#sources.go = ['omni', 'neosnippet']

	" enable heavy omni completion
	" if !exists('g:neocomplete#force_omni_input_patterns')
	"	let g:neocomplete#force_omni_input_patterns = {}
	" endif
	" let g:neocomplete#force_omni_input_patterns.go = '[^.[:digit:] *\t]\.'

	" Plugin key-mappings.
	inoremap <expr><C-g> neocomplete#undo_completion()
	inoremap <expr><C-l> neocomplete#complete_common_string()

	imap <C-k>     <Plug>(neosnippet_expand_or_jump)
	smap <C-k>     <Plug>(neosnippet_expand_or_jump)
	xmap <C-k>     <Plug>(neosnippet_expand_target)
	nnoremap <leader>es :NeoSnippetEdit<CR>

	let g:neosnippet#snippets_directory = "~/.vim/neosnippets"

	" For conceal markers.
	" if has('conceal')
		"set conceallevel=2 concealcursor=niv
	"endif
endif

set splitright " split vertically to the right

" let's give this a try
set clipboard^=unnamed
set clipboard^=unnamedplus

" just a test
set lazyredraw

" manage tabs
map <Leader>te :tabnew<cr>
map <Leader>to :tabonly<cr>
map <Leader>tm :tabmove<Space>
map <Leader>tn :tabnext<cr>
map <Leader>tp :tabprevious<cr>

" vim: set list ts=2 sw=2:
