" generated by puppet from: modules/accounts/files/xnicollet/.vimrc

set encoding=utf-8
set nocompatible

syntax on
syntax sync minlines=512 " start highlighting from 512 lines backward
set synmaxcol=300 " do noe highlight very long lines
set bg=dark

filetype plugin indent on

au BufRead,BufNewFile Vagrantfile setfiletype ruby
set modelines=5
set modeline

" pas de highlight abusif
set nohls

" set list | set nolist
" set listchars=tab:\|-,trail:.
set listchars=tab:Â»\ ,trail:.,nbsp:~

"  " should be called before go plugin is launched
"  function! GoHtml()
"  	GoFmt
"  	if !empty(b:current_syntax)
"  		unlet b:current_syntax
"   	endif
"   	syn include @html syntax/html.vim
"  	syntax region htmlCode start=+<!DOCTYPE+ keepend end=+</html>+ contains=@html containedin=goRawString contained
"  endfunction
"
"  " autocmd BufEnter *.go call GoHtml()
"  autocmd BufWrite *.go call GoHtml()

" http://stackoverflow.com/questions/18576651/check-whether-pathogen-is-installed-in-vimrc
runtime! autoload/pathogen.vim
if exists("*pathogen#infect")
	call pathogen#infect()
endif

filetype plugin indent on

inoremap jk <Esc>l

" remove arrows
for prefix in ['i', 'n', 'v']
	for key in ['<Up>', '<Down>', '<Left>', '<Right>']
		exe prefix . "noremap " . key . " <Nop>"
	endfor
endfor

let mapleader = "\<Space>"

if &runtimepath =~ 'vim-go'
	function! FormatAndImports()
		GoFmt
		GoImports
	endfunction

	function! SetGoOptions()
		nmap <Leader>gr <Plug>(go-run)
		nmap <Leader>gb <Plug>(go-build)
		nmap <Leader>gt <Plug>(go-test)
		nmap <Leader>gT <Plug>(go-test-func)
		nmap <Leader>gR <Plug>(go-rename)
		nmap <Leader>gf <Plug>(go-freevars)
		nmap <Leader>gl <Plug>(go-metalinter)
		nmap <Leader>ga <Plug>(go-alternate-edit)
		nmap <Leader>gc <Plug>(go-coverage-toggle)
		nmap <Leader>gd <Plug>(go-doc)
		nmap <Leader>gD <Plug>(go-describe)
		nmap <Leader>gi <Plug>(go-info)

		set list
		let g:go_fmt_autosave = 0
		let g:go_fmt_options = "-s -w"

		" for golang: automatically run GoImports
		" let g:go_fmt_command = "GoImports"
		" simplify code when formatting
		autocmd BufWritePre *.go call FormatAndImports()

		" some stuff from github.com/fatih/vim-go-tutorial
		let g:go_list_type = "quickfix"
		let g:go_highlight_build_constraints = 1

	endfunction


	"	augroup golang
	"		autocmd!
	au FileType go call SetGoOptions()
	au FileType go setl list ts=2 sw=2 noet
	"	augroup end
endif

augroup puppet
	au FileType puppet setl list ts=2 sw=2 et
augroup end

augroup vim
	au FileType vim setl list ts=2 sw=2 noet
augroup end

" Google style guide for bash
augroup bash
	autocmd!
	au FileType sh setl list sw=2 ts=2 et
augroup end

" let's test hidden mode
set hidden

nnoremap ' `
nnoremap ` '

set history=100
set visualbell

cnoremap w!! w !sudo tee %
" make C-g behave like C-c in command mode
cnoremap <C-g> <C-c>

" todo remap set number to set number relativenumber
" when printing number, use relative numbers so that we can 3dd easily
" set relativenumber

" open vimrc more easily
nnoremap <Leader>ev :e $MYVIMRC<cr>
" todo: improve this: should only save $MYVIMRC
nnoremap <Leader>sv :w<cr> :source $MYVIMRC<cr>
" should find a way to close it easily

" sane backspace
set backspace=2

" don't put too large text by mistake
highlight ColorColumn ctermbg=darkblue
call matchadd('ColorColumn', '\%81v', 100)

set laststatus=2
" we need more colors
" set t_Co=256

" know where the cursor is located
set noruler

" http://got-ravings.blogspot.com/2008/08/vim-pr0n-making-statuslines-that-own.html
set statusline=   " clear the statusline for when vimrc is reloaded

" syntastic
if exists('SyntasticStatuslineFlag')
	set statusline+=%#warningmsg#
	set statusline+=%{SyntasticStatuslineFlag()}
	set statusline+=%*
endif

set statusline+=%-3.3n\                      " buffer number
set statusline+=%f\                          " file name
set statusline+=%h%m%r%w                     " flags
set statusline+=[%{strlen(&ft)?&ft:'none'},  " filetype
set statusline+=%{strlen(&fenc)?&fenc:&enc}, " encoding
set statusline+=%{&fileformat}]              " file format
set statusline+=%=                           " right align
" set statusline+=%{synIDattr(synID(line('.'),col('.'),1),'name')}\  " highlight
" set statusline+=%b,0x%-8B\                   " current char
" set statusline+=%-14.(%l,%c%V%)\ %<%P        " offset
set statusline+=%10((%l,%c)%)\            " line and column
set statusline+=%p%%                        " percentage of file

" help for file
set wildmenu
" set wildmode=longest,list:full
" testing a new version
set wildmode=list:longest,full
" Ignore compiled files
set wildignore+=.o,~,pyc
set wildignore+=.git,.hg,.svn

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

" just a try: let's forget ;
nnoremap ; :
" maybe later:  nnoremap : ;

set autowrite

" Looks like unimpaired.vim
function! s:setup_paste() abort
	set paste
	augroup unimpaired_paste
		autocmd!
		autocmd InsertLeave *
			\ set nopaste |
			\ autocmd! unimpaired_paste
	augroup end
endfunction

nnoremap <silent> yo :call <SID>setup_paste()<CR>o
nnoremap <silent> yO :call <SID>setup_paste()<CR>O

set completeopt=menu,menuone
if &runtimepath =~ 'neocomplete'
	let g:acp_enableAtStartup = 0
	let g:neocomplete#enable_at_startup = 1
	let g:neocomplete#enable_smart_case = 1

	if !exists('g:neocomplete#sources')
		let g:neocomplete#sources = {}
	endif
	let g:neocomplete#sources._ = ['buffer', 'member', 'tag', 'file', 'dictionary']
	let g:neocomplete#sources.go = ['omni']

	" enable heavy omni completion
	" if !exists('g:neocomplete#force_omni_input_patterns')
	"	let g:neocomplete#force_omni_input_patterns = {}
	" endif
	" let g:neocomplete#force_omni_input_patterns.go = '[^.[:digit:] *\t]\.'

	" Plugin key-mappings.
	"inoremap <expr><C-g> neocomplete#undo_completion()
	"inoremap <expr><C-l> neocomplete#complete_common_string()

	"imap <C-k>     <Plug>(neosnippet_expand_or_jump)
	"smap <C-k>     <Plug>(neosnippet_expand_or_jump)
	"xmap <C-k>     <Plug>(neosnippet_expand_target)
	"nnoremap <leader>es :NeoSnippetEdit<CR>

	"let g:neosnippet#snippets_directory = "~/.vim/neosnippets"

	" For conceal markers.
	" if has('conceal')
		"set conceallevel=2 concealcursor=niv
	"endif
endif

set splitright " split vertically to the right

" let's give this a try
set clipboard^=unnamed
set clipboard^=unnamedplus

" just a test
set lazyredraw

" manage tabs
map <Leader>te :tabnew<cr>
map <Leader>to :tabonly<cr>
map <Leader>tm :tabmove<Space>

function! GitGrep()
	echom "gitgrep"
	execute "normal! :Grep <cwords -- './*' ':!*.js' ':!*.css'<cr>"
	execute "normal! :copen<cr>"
endfunction

nnoremap <Leader>] :call GitGrep()<cr>

" temp
" au BufWritePost *.html make

command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis 
	\ | wincmd p | diffthis

" toggle quickfix with q
function! Qf_toggle()
	for i in range(1, winnr('$'))
		let bnum = winbufnr(i)
		if getbufvar(bnum, '&buftype') == 'quickfix'
			cclose
			return
		elseif getbufvar(bnum, '&buftype') == 'help'
			helpc
			return
		endif
	endfor
	copen
endfunction

" remove quickfix or help screen with q
nnoremap <Leader>q q
nnoremap q :call Qf_toggle()<cr>

" Comments
function! s:GetMinOffset(firstl, lastl)
	let l:list = []
	for l:ln in range(a:firstl, a:lastl)
		let l:match = match(getline(l:ln), '\S')
		if l:match != -1
			let l:list += [l:match]
		endif
	endfor
	return min(l:list)
endfunction

let g:comment_type = {'vim': '"', 'sh': '#', 'python': '#'}

function! s:GetComment()
	if has_key(g:comment_type, &filetype)
		return g:comment_type[&filetype]
	endif
	return '//'
endfunction

function! Comment() range
	let l:oldpos = getpos('.')
	let l:comment = s:GetComment()

	" get the minimum offset
	let l:offset = s:GetMinOffset(a:firstline, a:lastline)

	for l:line in range(a:firstline, a:lastline)
		call cursor(l:line, offset + 1)
		let l:pos = getcurpos()
		execute "normal! i" . comment . " "
		if l:pos[2] != offset + 1
			execute "normal! =="
		endif
		call setline(l:line, substitute(getline("."), '\s*$', '', ''))
	endfor
	call setpos('.', l:oldpos)
endfunction

function! Uncomment() range
	let l:oldpos = getpos('.')
	let l:comment = s:GetComment()
	
	for l:line in range(a:firstline, a:lastline)
		call cursor(l:line, 1)
		let l:found = search(comment, 'c', l:line)
		if l:found != 0
			execute "normal! " . strlen(l:comment) . "x"
			" remove the last space
			if getchar(".") == ' '
				execute "normal! x"
			endif
		endif
	endfor
	call setpos('.', l:oldpos)
endfunction

command! -range Comment <line1>,<line2>call Comment()
command! -range Uncomment <line1>,<line2>call Uncomment()

vmap <Leader>cc :Comment<cr>
vmap <Leader>cu :Uncomment<cr>
nmap <Leader>cc :Comment<cr>
nmap <Leader>cu :Uncomment<cr>

" comment the current line/region

" vim: set list ts=2 sw=2:
