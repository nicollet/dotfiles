# have colors on MacOsX
export CLICOLOR=1
export LSCOLORS=ExFxCxDxBxegedabagacad
export SCREENRC=.screenrc-Darwin
export PS1="${USER/xnicollet/xa}@mac:\w"'${debian_chroot:+($debian_chroot)}'"\$ "

alias ssh=my_ssh

# [[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm" # Load RVM into a shell session *as a function*

append PATH "/usr/local/go/bin"
export PATH

alias vim='/usr/local/bin/vim'
alias vi='/usr/local/bin/vim'

export EDITOR=/usr/local/bin/vim

# docker run for fpm
# docker run -v $HOME:$HOME --name fpm --rm -t -i xa/fpm bash

# some bash customizations from https://github.com/mrzoo/bash-sensible/

# automatically trim long paths in the prompt (bash 4.x)
PROMPT_DIRTRIM=3

# turn on recursive globbing
shopt -s globstar 2> /dev/null

# Record each line as it gets issued
# PROMPT_COMMAND='history -a'

# correct spelling errors in arguments supplied to cd
shopt -s cdspell 2> /dev/null

alias mount="mount | column -t"

# Load RVM into a shell session *as a function*
[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"

#export VIMPUPPET="~/stack/git/gitlab/puppet/modules/accounts/files/xnicollet/.vimrc"
#alias diffvimrc="vimdiff ~/.vimrc ${VIMPUPPET}"
#alias updatevimrc="cp ~/.vimrc ${VIMPUPPET}"

update_cdstat() {
  local max_stat=100
  [ "$1" == "" ] && return
  local newpath=$1
  # count date_sec path
  local found=0
  local now=`date +%s`
  { while read count date path ; do
    [ "$path" == "$newpath" ] && { ((count++)) ; date=$now ; found=1 ; }
    echo "$count $date $path"
  done < ~/.cdstat
  [ "$found" -eq 0 ] && echo "1 $now $newpath"
  } | sort -nr | tail -$max_stat > ~/.cdstat.tmp
  sync
  mv ~/.cdstat{.tmp,}
}

# use the go binary if available (10 times faster)
# go get github.com/nicollet/update_cdstats
update_cdstat_command=`which update_cdstats || echo update_cdstat`

cd() {
  [[ "${1}" == -* || "$1" == "" ]] && { builtin cd $* ; return $? ; }
  realpath=`realpath $1` # check realpath before we cd into new dir
  builtin cd $* && $update_cdstat_command $realpath
}

cdpath=`realpath ~/.cdd_path`
[ -f "$cdpath" ] || touch $cdpath

_fzf_compgen_dir() {
  sed 's/\s*#.*//' < $cdpath | grep -v '^$' | cat - <(cut -d' ' -f3- ~/.cdstat) | sort -u
}

cdd() {
  local query=""
  [ -n "$1" ] && query="-q $1"
  local get_cdstat=""
  local fzf_options="+m -1 --tiebreak=end,index"
  local dest_dir=`_fzf_compgen_dir | fzf $fzf_options $query`
  [ -n "$dest_dir" ] && builtin cd "$dest_dir" && $update_cdstat_command $dest_dir
}

cdp() {
  [ -n "$1" ] && dir=`realpath "$1"` || dir=`pwd`
  grep -q -F -x "$dir" $cdpath || echo -e "$dir" >> $cdpath
}

cdrm() {
  local filter=""
  [ -n "$1" ] && filter="-q $1"
  local to_rm=`fzf +m $filter < $cdpath`
  # https://unix.stackexchange.com/a/204378/144167
  [ -n "$to_rm" ] && {
    cat < $cdpath | grep -v -F -x -- "$to_rm"
    perl -e 'truncate STDOUT, tell STDOUT'
  } 1<> $cdpath
}

cdls() {
  cat $cdpath
}

# try a complete cdd
_cdd() {
  COMPREPLY=()
  #local cur="${COMP_WORDS[COMP_CWORD]}"
  #local prev="${COMP_WORDS[COMP_CWORD-1]}"
  [ "$1" == "cdd" ] || return 0
  local fzf="fzf --tiebreak=end,index -f $2"
  [ "$2" == "" ] && fzf="cat"
  readarray -t COMPREPLY < <(_fzf_compgen_dir | $fzf | sort -u)
  #echo comreply0: ${COMREPLY[*]}
  return 0
}
complete -F _cdd -o dirnames cdd
# todo: cd
# todo: normal completion suffix? ,,
# todo: see double tab


# [ -f ~/.fzf.bash ] && source ~/.fzf.bash
