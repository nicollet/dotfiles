# have colors on MacOsX
export CLICOLOR=1
export LSCOLORS=ExFxCxDxBxegedabagacad
export SCREENRC=.screenrc-Darwin


PS_SYMBOL_DARWIN=''
PS_SYMBOL_LINUX='$'
PS_SYMBOL_OTHER='%'
GIT_BRANCH_SYMBOL='⑂ '
GIT_BRANCH_CHANGED_SYMBOL='+'
GIT_NEED_PUSH_SYMBOL='⇡'
GIT_NEED_PULL_SYMBOL='⇣'

FG_RED="\[$(tput setaf 1)\]"
RESET="\[$(tput sgr0)\]"

_idroot() {
  whoami | grep -q '^root$'
}

_idcolor() {
   _idroot && echo "${FG_RED}\\\$" || echo '$'
}

export PS1="${USER/xnicollet/}@:\w`_idcolor`${RESET} "
PS1_=$PS1

set_ps1() {
  [ "$TERM"="screen" ] || return
  PWD_=${PWD/\/Users\/xnicollet/\~}
  #_idroot && PS1="\[\e]0;${PWD_}\a\]$PS1_" || { 
    # PWD_=${PWD_/\~/^%{.g\}\~^%{-\}} # make ~ green
  #  screen -X eval "hstatus '$PWD_'"
  #}
  screen -X eval "hstatus '$PWD_'"
  #PS1="\[\e]0;\]${PWD_}\[\a\]$PS1_"
  #PS1="${PWD_}\[\a\]$PS1_"
}

PROMPT_COMMAND=set_ps1

# from http://jonisalonen.com/2012/your-bash-prompt-needs-this/
# PS1="\[\033[G\]$PS1"

alias ssh=my_ssh
alias cd..='cd ../'
alias ..='cd ../'
alias ...='cd ../../'

append PATH "/usr/local/go/bin"
export PATH

alias vim='/usr/local/bin/vim'
alias vi='/usr/local/bin/vim'

export EDITOR=/usr/local/bin/vim

# docker run for fpm
# docker run -v $HOME:$HOME --name fpm --rm -t -i xa/fpm bash

# some bash customizations from https://github.com/mrzoo/bash-sensible/

# automatically trim long paths in the prompt (bash 4.x)
PROMPT_DIRTRIM=3

# turn on recursive globbing
shopt -s globstar 2> /dev/null

# Record each line as it gets issued
# PROMPT_COMMAND='history -a'

# correct spelling errors in arguments supplied to cd
shopt -s cdspell 2> /dev/null

alias mount="mount | column -t"

# Load RVM into a shell session *as a function*
[[ -s "$HOME/.rvm/scripts/rvm" ]] && source "$HOME/.rvm/scripts/rvm"

#export VIMPUPPET="~/stack/git/gitlab/puppet/modules/accounts/files/xnicollet/.vimrc"
#alias diffvimrc="vimdiff ~/.vimrc ${VIMPUPPET}"
#alias updatevimrc="cp ~/.vimrc ${VIMPUPPET}"

update_cdstat() {
  local max_stat=100
  [ "$1" == "" ] && return
  local newpath=$1
  # count date_sec path
  local found=0
  local now=`date +%s`
  { while read count date path ; do
    [ "$path" == "$newpath" ] && { ((count++)) ; date=$now ; found=1 ; }
    echo "$count $date $path"
  done < ~/.cdstat
  [ "$found" -eq 0 ] && echo "1 $now $newpath"
  } | sort -nr | tail -$max_stat > ~/.cdstat.tmp
  sync
  mv ~/.cdstat{.tmp,}
}

# use the go binary if available (10 times faster)
# go get github.com/nicollet/update_cdstats
update_cdstat_command=`which update_cdstats || echo update_cdstat`

cd() {
  [[ "${1}" == -* || "$1" == "" ]] && { builtin cd $* ; return $? ; }
  realpath=`realpath $1` # check realpath before we cd into new dir
  builtin cd $* && $update_cdstat_command $realpath
}

cdpath=`realpath ~/.cdd_path`
[ -f "$cdpath" ] || touch $cdpath

_fzf_compgen_dir() {
  sed 's/\s*#.*//' < $cdpath | grep -v '^$' | cat - <(cut -d' ' -f3- ~/.cdstat) | sort -u
}

cdp() {
  [ -n "$1" ] && dir=`realpath "$1"` || dir=`pwd`
  grep -q -F -x "$dir" $cdpath || echo -e "$dir" >> $cdpath
}

cdrm() {
  local filter=""
  [ -n "$1" ] && filter="-q $1"
  local to_rm=`fzf +m $filter < $cdpath`
  # https://unix.stackexchange.com/a/204378/144167
  [ -n "$to_rm" ] && {
    cat < $cdpath | grep -v -F -x -- "$to_rm"
    perl -e 'truncate STDOUT, tell STDOUT'
  } 1<> $cdpath
}

cdls() {
  cat $cdpath
}

function _cd_comp() {
  #echo "|${READLINE_LINE:$READLINE_POINT:1}|"

  local words=()
  read -a words < <(echo $READLINE_LINE)
  [ -z $words ] && return
  local last=${words[-1]}
  local search=""
  [ "$last" == "" ] || search="-q $last"
  # local bind_='tab:accept,enter:execute(echo\\ ,,exe{})'
  local bind_='tab:accept'
  local fzf="fzf --tiebreak=end,index $search --reverse --height 30% "
  local found=$(_fzf_compgen_dir | $fzf --bind $bind_)

  # if we are completing an empty word
  local b=$(( READLINE_POINT - 1))
  [[ ${READLINE_LINE:$b:1} == " " ]] && words+=('replace_me')

  words[-1]=$found

  READLINE_LINE=${words[*]}
  READLINE_POINT=${#READLINE_LINE}
}

builtin bind '"\er": redraw-current-line'
builtin bind '"\e^": magic-space'


# test some bindings
bind -x '"\C-x2": _cd_comp'
bind '"\C-xj": "\C-x2\e^\er"'

# fixme c-o
stty discard undef
bind -r "\C-o"
bind '"\C-of": "\C-x2\e^\er"'
bind '"\C-oo": operate-and-get-next'

bind -m vi-insert '"jk": vi-movement-mode'

# complete only on diretories for those commands
complete -d cd
complete -d rmdir

